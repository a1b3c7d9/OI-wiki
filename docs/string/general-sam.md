
(不会sam的人请先学sam，忽略证明，具体参考2015集训队论文)

#### 概述

广义sam与sam类似，只是有部分地不同，sam是对一个字符串建，而广义sam是对一个trie树（或者说是字典树）建的(所以才说是广义，原来那个sam不如也可以叫做狭义sam)，它的一条到源点路径，表示的是trie树上的一条直链，目前有两种建法，基本上满足sam中所有的一切性质，但具体证明还得看论文，以下设trie节点数为$n$,字符集为$\sum$。

#### bfs

按照bfs序遍历字典树，对于节点$x$，我们记$a_x$表示$x$到字典树根的路径所得到的字符串在广义sam中对应的状态，那么当我们遍历到$x$的时候，我们就以$a_{fa_x}$(其中$fa_x$表示$x$在字典树上的父亲)为$last$，然后执行$sam$的extend操作，这样得到的sam就是我们想要的sam，时间复杂度是$O(n|\sum|)$，这种做法必须得离线。

#### dfs

做法和bfs建sam完全一样，唯一的不同之处在于按bfs序遍历，改成按照$dfs$序遍历，时间复杂度比bfs建树多了一个trie树的叶子节点深度之和，该做法可以在线，适合做毒瘤题。

#### [模板](https://codeforces.com/problemset/problem/666/E)
